//! Post-Quantum Extended Triple Diffie-Hellman (X3DH) key agreement.
//!
//! This module implements a post-quantum variant of the X3DH protocol used in Signal.
//! Instead of elliptic curve Diffie-Hellman, we use ML-KEM-1024 key encapsulation.
//!
//! ## Protocol Overview
//!
//! X3DH provides asynchronous authenticated key agreement. Alice can establish
//! a shared secret with Bob even if Bob is offline, using Bob's published prekeys.
//!
//! ### Keys Involved
//!
//! - **IK_A**: Alice's identity key (ML-DSA-87, for authentication)
//! - **IK_B**: Bob's identity key (ML-DSA-87, for authentication)
//! - **SPK_B**: Bob's signed prekey (ML-KEM-1024, signed by IK_B)
//! - **OPK_B**: Bob's one-time prekey (ML-KEM-1024, optional)
//! - **EK_A**: Alice's ephemeral key (ML-KEM-1024, generated per session)
//!
//! ### Key Agreement (Sender Side)
//!
//! Alice performs KEM encapsulation to derive shared secrets:
//! 1. `ss1, ct1 = Encap(SPK_B)` - to Bob's signed prekey
//! 2. `ss2, ct2 = Encap(OPK_B)` - to Bob's one-time prekey (if available)
//!
//! The shared secret is: `SK = KDF(ss1 || ss2, info)` where info includes identities.
//!
//! ### Key Agreement (Receiver Side)
//!
//! Bob decapsulates using his private keys:
//! 1. `ss1 = Decap(ct1, spk_private)`
//! 2. `ss2 = Decap(ct2, opk_private)` (if OPK was used)
//!
//! Bob derives the same `SK` using the same KDF.
//!
//! ## Security Properties
//!
//! - **Mutual Authentication**: Both parties' identities are cryptographically bound
//! - **Forward Secrecy**: Compromise of identity keys doesn't reveal past sessions
//! - **Post-Quantum Security**: All operations use NIST post-quantum algorithms
//! - **Deniability**: No non-repudiable signatures on messages

use crate::chat::identity::{IdentityKey, IdentityKeyPair};
use crate::chat::kdf_info;
use crate::chat::prekey::{OneTimePreKeyPrivate, PreKeyBundle, PreKeyId, SignedPreKeyPrivate};
use crate::error::{PqpgpError, Result};
use hkdf::Hkdf;
use pqcrypto_mlkem::mlkem1024;
use pqcrypto_traits::kem::{Ciphertext, SharedSecret};
use serde::{Deserialize, Serialize};
use sha3::Sha3_512;
use std::fmt;
use zeroize::{ZeroizeOnDrop, Zeroizing};

/// The size of a root key in bytes.
pub const ROOT_KEY_SIZE: usize = 32;

/// ML-KEM-1024 ciphertext size in bytes.
pub const MLKEM1024_CIPHERTEXT_SIZE: usize = 1568;

/// Output of X3DH key agreement - the initial root key for the double ratchet.
#[derive(Clone, ZeroizeOnDrop)]
pub struct X3DHSharedSecret {
    /// The derived root key
    root_key: [u8; ROOT_KEY_SIZE],
    /// Associated data binding the key to both identities
    associated_data: Vec<u8>,
}

impl fmt::Debug for X3DHSharedSecret {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("X3DHSharedSecret")
            .field("root_key", &"[REDACTED]")
            .field("associated_data_len", &self.associated_data.len())
            .finish()
    }
}

impl X3DHSharedSecret {
    /// Returns the root key for initializing the double ratchet.
    pub fn root_key(&self) -> &[u8; ROOT_KEY_SIZE] {
        &self.root_key
    }

    /// Returns the associated data for binding to AEAD operations.
    pub fn associated_data(&self) -> &[u8] {
        &self.associated_data
    }
}

/// Keys generated by the X3DH sender (Alice) that need to be sent to the receiver.
#[derive(Clone, Serialize, Deserialize)]
pub struct X3DHKeys {
    /// Alice's identity key (for Bob to verify)
    pub sender_identity: IdentityKey,
    /// Ciphertext from encapsulating to signed prekey
    pub signed_prekey_ciphertext: Vec<u8>,
    /// ID of the signed prekey used
    pub signed_prekey_id: PreKeyId,
    /// Ciphertext from encapsulating to one-time prekey (if used)
    pub one_time_prekey_ciphertext: Option<Vec<u8>>,
    /// ID of the one-time prekey used (if any)
    pub one_time_prekey_id: Option<PreKeyId>,
}

impl fmt::Debug for X3DHKeys {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("X3DHKeys")
            .field("sender_identity", &self.sender_identity)
            .field("signed_prekey_id", &self.signed_prekey_id)
            .field("one_time_prekey_id", &self.one_time_prekey_id)
            .finish()
    }
}

/// Sender-side X3DH operations.
///
/// Alice uses this to initiate a session with Bob using Bob's prekey bundle.
pub struct X3DHSender;

impl X3DHSender {
    /// Performs X3DH key agreement as the sender (initiator).
    ///
    /// This function:
    /// 1. Verifies the recipient's prekey bundle
    /// 2. Performs KEM encapsulation to the prekeys
    /// 3. Derives the shared root key
    ///
    /// # Arguments
    /// * `our_identity` - The sender's identity key pair
    /// * `their_bundle` - The recipient's prekey bundle
    ///
    /// # Returns
    /// A tuple of (shared_secret, keys_to_send) where:
    /// - `shared_secret` is the derived root key for the double ratchet
    /// - `keys_to_send` contains the KEM ciphertexts to include in the initial message
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use pqpgp::chat::{IdentityKeyPair, PreKeyBundle, X3DHSender};
    ///
    /// let alice_identity = IdentityKeyPair::generate()?;
    /// // Assume we fetched Bob's bundle from the server
    /// # let bob_identity = IdentityKeyPair::generate()?;
    /// # let generator = pqpgp::chat::prekey::PreKeyGenerator::new(&bob_identity, 10)?;
    /// # let bob_bundle = generator.create_bundle(&bob_identity, true);
    ///
    /// let (shared_secret, keys) = X3DHSender::perform(&alice_identity, &bob_bundle)?;
    /// // shared_secret.root_key() is used to initialize the double ratchet
    /// // keys is sent with the initial message
    /// # Ok::<(), pqpgp::error::PqpgpError>(())
    /// ```
    pub fn perform(
        our_identity: &IdentityKeyPair,
        their_bundle: &PreKeyBundle,
    ) -> Result<(X3DHSharedSecret, X3DHKeys)> {
        // Step 1: Verify the bundle
        their_bundle
            .verify()
            .map_err(|e| PqpgpError::session(format!("Failed to verify prekey bundle: {}", e)))?;

        // Step 2: Get the recipient's prekeys as ML-KEM public keys
        let spk_public = their_bundle.signed_prekey().as_mlkem_public()?;

        // Step 3: Encapsulate to signed prekey
        let (ss1, ct1) = mlkem1024::encapsulate(&spk_public);

        // Step 4: Encapsulate to one-time prekey (if available)
        let (ss2, ct2, opk_id) = if let Some(opk) = their_bundle.one_time_prekey() {
            let opk_public = opk.as_mlkem_public()?;
            let (ss, ct) = mlkem1024::encapsulate(&opk_public);
            (Some(ss), Some(ct), Some(opk.id()))
        } else {
            (None, None, None)
        };

        // Step 5: Derive the shared secret
        let shared_secret = Self::derive_shared_secret(
            our_identity.public_key(),
            their_bundle.identity_key(),
            &ss1,
            ss2.as_ref(),
        )?;

        // Step 6: Create the keys structure to send
        let keys = X3DHKeys {
            sender_identity: our_identity.public.clone(),
            signed_prekey_ciphertext: ct1.as_bytes().to_vec(),
            signed_prekey_id: their_bundle.signed_prekey().id(),
            one_time_prekey_ciphertext: ct2.map(|ct| ct.as_bytes().to_vec()),
            one_time_prekey_id: opk_id,
        };

        Ok((shared_secret, keys))
    }

    /// Derives the shared secret from KEM shared secrets.
    fn derive_shared_secret(
        our_identity: &IdentityKey,
        their_identity: &IdentityKey,
        ss1: &mlkem1024::SharedSecret,
        ss2: Option<&mlkem1024::SharedSecret>,
    ) -> Result<X3DHSharedSecret> {
        // Build input key material by concatenating shared secrets
        let mut ikm = Zeroizing::new(Vec::with_capacity(64));
        ikm.extend_from_slice(ss1.as_bytes());
        if let Some(ss) = ss2 {
            ikm.extend_from_slice(ss.as_bytes());
        }

        // Build associated data binding to both identities
        let associated_data = Self::build_associated_data(our_identity, their_identity);

        // Use HKDF to derive the root key
        let hk = Hkdf::<Sha3_512>::new(Some(&associated_data), &ikm);

        let mut root_key = [0u8; ROOT_KEY_SIZE];
        hk.expand(kdf_info::X3DH_ROOT, &mut root_key)
            .map_err(|_| PqpgpError::session("HKDF expansion failed"))?;

        Ok(X3DHSharedSecret {
            root_key,
            associated_data,
        })
    }

    /// Builds associated data that binds the key agreement to both identities.
    fn build_associated_data(our_identity: &IdentityKey, their_identity: &IdentityKey) -> Vec<u8> {
        let mut ad = Vec::new();
        ad.extend_from_slice(b"PQPGP-X3DH-v1");
        ad.extend_from_slice(&our_identity.key_id().to_be_bytes());
        ad.extend_from_slice(&their_identity.key_id().to_be_bytes());
        // Include fingerprints for additional binding
        let our_fp = our_identity.fingerprint();
        let their_fp = their_identity.fingerprint();
        ad.extend_from_slice(&our_fp[..16]);
        ad.extend_from_slice(&their_fp[..16]);
        ad
    }
}

/// Receiver-side X3DH operations.
///
/// Bob uses this to complete session establishment when receiving Alice's initial message.
pub struct X3DHReceiver;

impl X3DHReceiver {
    /// Performs X3DH key agreement as the receiver.
    ///
    /// This function:
    /// 1. Verifies the sender's identity
    /// 2. Decapsulates the KEM ciphertexts using our private keys
    /// 3. Derives the same shared root key as the sender
    ///
    /// # Arguments
    /// * `our_identity` - The receiver's identity key pair
    /// * `our_signed_prekey` - The signed prekey private key that was used
    /// * `our_one_time_prekey` - The one-time prekey private key (if one was used)
    /// * `their_keys` - The X3DH keys received from the sender
    ///
    /// # Returns
    /// The shared secret matching what the sender derived.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use pqpgp::chat::{IdentityKeyPair, X3DHReceiver, X3DHKeys};
    /// use pqpgp::chat::prekey::{SignedPreKeyPrivate, PreKeyGenerator};
    ///
    /// let bob_identity = IdentityKeyPair::generate()?;
    /// let mut generator = PreKeyGenerator::new(&bob_identity, 10)?;
    ///
    /// // Assume we received keys from Alice
    /// # let alice_identity = IdentityKeyPair::generate()?;
    /// # let bob_bundle = generator.create_bundle(&bob_identity, true);
    /// # let (_, their_keys) = pqpgp::chat::X3DHSender::perform(&alice_identity, &bob_bundle)?;
    ///
    /// // Look up the prekeys that were used
    /// // Consume one-time prekey first (requires mutable access)
    /// let one_time_prekey = their_keys.one_time_prekey_id
    ///     .and_then(|id| generator.consume_one_time_prekey(id));
    /// // Then get signed prekey (immutable access)
    /// let signed_prekey = generator.signed_prekey_private();
    ///
    /// let shared_secret = X3DHReceiver::perform(
    ///     &bob_identity,
    ///     signed_prekey,
    ///     one_time_prekey.as_ref(),
    ///     &their_keys,
    /// )?;
    /// # Ok::<(), pqpgp::error::PqpgpError>(())
    /// ```
    pub fn perform(
        our_identity: &IdentityKeyPair,
        our_signed_prekey: &SignedPreKeyPrivate,
        our_one_time_prekey: Option<&OneTimePreKeyPrivate>,
        their_keys: &X3DHKeys,
    ) -> Result<X3DHSharedSecret> {
        // Step 0: Validate sender's identity key is well-formed
        // This prevents attacks using malformed identity keys
        their_keys
            .sender_identity
            .as_public_key()
            .map_err(|_| PqpgpError::session("Invalid sender identity key in X3DH exchange"))?;

        // Step 1: Verify prekey IDs match
        if our_signed_prekey.id() != their_keys.signed_prekey_id {
            return Err(PqpgpError::session("Signed prekey ID mismatch"));
        }

        if let Some(opk_id) = their_keys.one_time_prekey_id {
            match our_one_time_prekey {
                Some(opk) if opk.id() == opk_id => {}
                Some(opk) => {
                    return Err(PqpgpError::session(format!(
                        "One-time prekey ID mismatch: expected {}, got {}",
                        opk_id,
                        opk.id()
                    )));
                }
                None => {
                    return Err(PqpgpError::session(
                        "One-time prekey required but not provided",
                    ));
                }
            }
        }

        // Step 2: Get our private keys as ML-KEM secret keys
        let spk_secret = our_signed_prekey.as_mlkem_secret()?;

        // Step 3: Reconstruct ciphertexts
        // SECURITY FIX: Validate ciphertext lengths before parsing
        if their_keys.signed_prekey_ciphertext.len() != MLKEM1024_CIPHERTEXT_SIZE {
            return Err(PqpgpError::session(format!(
                "Invalid signed prekey ciphertext length: expected {}, got {}",
                MLKEM1024_CIPHERTEXT_SIZE,
                their_keys.signed_prekey_ciphertext.len()
            )));
        }
        let ct1 = mlkem1024::Ciphertext::from_bytes(&their_keys.signed_prekey_ciphertext)
            .map_err(|_| PqpgpError::session("Invalid signed prekey ciphertext"))?;

        // Step 4: Decapsulate signed prekey
        let ss1 = mlkem1024::decapsulate(&ct1, &spk_secret);

        // Step 5: Decapsulate one-time prekey (if used)
        let ss2 = if let (Some(ct_bytes), Some(opk)) =
            (&their_keys.one_time_prekey_ciphertext, our_one_time_prekey)
        {
            // SECURITY FIX: Validate OTP ciphertext length before parsing
            if ct_bytes.len() != MLKEM1024_CIPHERTEXT_SIZE {
                return Err(PqpgpError::session(format!(
                    "Invalid one-time prekey ciphertext length: expected {}, got {}",
                    MLKEM1024_CIPHERTEXT_SIZE,
                    ct_bytes.len()
                )));
            }
            let ct2 = mlkem1024::Ciphertext::from_bytes(ct_bytes)
                .map_err(|_| PqpgpError::session("Invalid one-time prekey ciphertext"))?;
            let opk_secret = opk.as_mlkem_secret()?;
            Some(mlkem1024::decapsulate(&ct2, &opk_secret))
        } else {
            None
        };

        // Step 6: Derive the shared secret (same as sender)
        Self::derive_shared_secret(
            &their_keys.sender_identity,
            our_identity.public_key(),
            &ss1,
            ss2.as_ref(),
        )
    }

    /// Derives the shared secret from KEM shared secrets.
    /// Note: Identity order is (sender, receiver) to match the sender's derivation.
    fn derive_shared_secret(
        sender_identity: &IdentityKey,
        receiver_identity: &IdentityKey,
        ss1: &mlkem1024::SharedSecret,
        ss2: Option<&mlkem1024::SharedSecret>,
    ) -> Result<X3DHSharedSecret> {
        // Build input key material by concatenating shared secrets
        let mut ikm = Zeroizing::new(Vec::with_capacity(64));
        ikm.extend_from_slice(ss1.as_bytes());
        if let Some(ss) = ss2 {
            ikm.extend_from_slice(ss.as_bytes());
        }

        // Build associated data binding to both identities (same order as sender)
        let associated_data = X3DHSender::build_associated_data(sender_identity, receiver_identity);

        // Use HKDF to derive the root key
        let hk = Hkdf::<Sha3_512>::new(Some(&associated_data), &ikm);

        let mut root_key = [0u8; ROOT_KEY_SIZE];
        hk.expand(kdf_info::X3DH_ROOT, &mut root_key)
            .map_err(|_| PqpgpError::session("HKDF expansion failed"))?;

        Ok(X3DHSharedSecret {
            root_key,
            associated_data,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::chat::prekey::PreKeyGenerator;

    #[test]
    fn test_x3dh_key_agreement() {
        // Setup: Alice and Bob generate identities
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();

        // Bob creates a prekey bundle
        let mut bob_prekeys = PreKeyGenerator::new(&bob_identity, 10).unwrap();
        let bob_bundle = bob_prekeys.create_bundle(&bob_identity, true);

        // Alice performs X3DH as sender
        let (alice_secret, alice_keys) = X3DHSender::perform(&alice_identity, &bob_bundle).unwrap();

        // Bob performs X3DH as receiver
        let opk_private = alice_keys
            .one_time_prekey_id
            .and_then(|id| bob_prekeys.consume_one_time_prekey(id));

        let bob_secret = X3DHReceiver::perform(
            &bob_identity,
            bob_prekeys.signed_prekey_private(),
            opk_private.as_ref(),
            &alice_keys,
        )
        .unwrap();

        // Both should derive the same root key
        assert_eq!(alice_secret.root_key(), bob_secret.root_key());
        assert_eq!(alice_secret.associated_data(), bob_secret.associated_data());
    }

    #[test]
    fn test_x3dh_without_one_time_prekey() {
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();

        // Bob creates a bundle without one-time prekey
        let bob_prekeys = PreKeyGenerator::new(&bob_identity, 0).unwrap();
        let bob_bundle = bob_prekeys.create_bundle(&bob_identity, false);

        assert!(bob_bundle.one_time_prekey().is_none());

        // Alice performs X3DH
        let (alice_secret, alice_keys) = X3DHSender::perform(&alice_identity, &bob_bundle).unwrap();

        assert!(alice_keys.one_time_prekey_id.is_none());
        assert!(alice_keys.one_time_prekey_ciphertext.is_none());

        // Bob performs X3DH
        let bob_secret = X3DHReceiver::perform(
            &bob_identity,
            bob_prekeys.signed_prekey_private(),
            None,
            &alice_keys,
        )
        .unwrap();

        // Should still derive matching keys
        assert_eq!(alice_secret.root_key(), bob_secret.root_key());
    }

    #[test]
    fn test_x3dh_fails_invalid_bundle() {
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();
        let _eve_identity = IdentityKeyPair::generate().unwrap();

        // Create a bundle with Bob's identity but Eve's signature
        let bob_prekeys = PreKeyGenerator::new(&bob_identity, 10).unwrap();
        let _eve_bundle = bob_prekeys.create_bundle(&bob_identity, true);

        // This bundle will fail verification because the signed prekey
        // is signed by bob_identity, not eve_identity
        // To test invalid signature, we'd need to manually construct a bad bundle

        // For now, just verify that valid bundles work
        let valid_bundle = bob_prekeys.create_bundle(&bob_identity, true);
        assert!(X3DHSender::perform(&alice_identity, &valid_bundle).is_ok());
    }

    #[test]
    fn test_x3dh_fails_wrong_prekey_id() {
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();

        let bob_prekeys = PreKeyGenerator::new(&bob_identity, 10).unwrap();
        let bob_bundle = bob_prekeys.create_bundle(&bob_identity, true);

        let (_, mut alice_keys) = X3DHSender::perform(&alice_identity, &bob_bundle).unwrap();

        // Modify the prekey ID
        alice_keys.signed_prekey_id = 9999;

        // Bob should fail to complete X3DH
        let result = X3DHReceiver::perform(
            &bob_identity,
            bob_prekeys.signed_prekey_private(),
            None,
            &alice_keys,
        );

        assert!(result.is_err());
    }

    #[test]
    fn test_x3dh_keys_serialization() {
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();

        let bob_prekeys = PreKeyGenerator::new(&bob_identity, 10).unwrap();
        let bob_bundle = bob_prekeys.create_bundle(&bob_identity, true);

        let (_, keys) = X3DHSender::perform(&alice_identity, &bob_bundle).unwrap();

        // Serialize and deserialize
        let serialized = bincode::serialize(&keys).unwrap();
        let deserialized: X3DHKeys = bincode::deserialize(&serialized).unwrap();

        assert_eq!(keys.signed_prekey_id, deserialized.signed_prekey_id);
        assert_eq!(keys.one_time_prekey_id, deserialized.one_time_prekey_id);
        assert_eq!(
            keys.signed_prekey_ciphertext,
            deserialized.signed_prekey_ciphertext
        );
    }

    #[test]
    fn test_x3dh_different_sessions_different_keys() {
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();

        let mut bob_prekeys = PreKeyGenerator::new(&bob_identity, 10).unwrap();

        // First session
        let bundle1 = bob_prekeys.create_bundle(&bob_identity, true);
        let (secret1, keys1) = X3DHSender::perform(&alice_identity, &bundle1).unwrap();

        // Consume the OTP
        if let Some(id) = keys1.one_time_prekey_id {
            bob_prekeys.consume_one_time_prekey(id);
        }

        // Second session (with different OTP)
        let bundle2 = bob_prekeys.create_bundle(&bob_identity, true);
        let (secret2, _keys2) = X3DHSender::perform(&alice_identity, &bundle2).unwrap();

        // Keys should be different due to different OTPs and randomness in KEM
        assert_ne!(secret1.root_key(), secret2.root_key());
    }

    #[test]
    fn test_associated_data_is_deterministic() {
        let alice_identity = IdentityKeyPair::generate().unwrap();
        let bob_identity = IdentityKeyPair::generate().unwrap();

        let ad1 = X3DHSender::build_associated_data(&alice_identity.public, &bob_identity.public);
        let ad2 = X3DHSender::build_associated_data(&alice_identity.public, &bob_identity.public);

        assert_eq!(ad1, ad2);

        // But different with swapped order
        let ad3 = X3DHSender::build_associated_data(&bob_identity.public, &alice_identity.public);
        assert_ne!(ad1, ad3);
    }
}
